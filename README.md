QEMU/Linux Stack
================

Build/Run Linux under QEMU.\
Only ``podman`` and ``qemu-user-static`` need to be installed.

Build is based on containers to ensure it can be reproduced on any machine.\
Rootfs is derived from a container image.\
Build is cached thanks to ``podman`` and ``ccache``, ensuring quick rebuilds.

All revisions are
[automatically](https://github.com/pbo-linaro/qemu-linux-stack/blob/master/.github/workflows/build.yml)
built, [tagged](https://github.com/pbo-linaro/qemu-linux-stack/tags),
and added to [build release](https://github.com/pbo-linaro/qemu-linux-stack/releases/tag/build).

Builds are generated with debug information (including macros) and frame
pointers enabled. As well, ``compile_commands.json`` is generated by default for
all the projects built using ``intercept-build`` from LLVM.\
This ensures a good developer experience out of the box.

**NOTE**: there is no ``clean`` command nor any dependency analysis.\
Every project is cloned in its own versioned folder, and a symlink is
dynamically set by each build script to point to the right version everytime.
Thus, update or switch branches should not require any ``git clean -ffdx``.

```
# build system using:
./build.sh

# run system using:
./run.sh /path/to/qemu-system-x86_64
# exit QEMU with ctrl-a + x

# debug kernel, firmwares and bootloader using:
./debug.sh /path/to/qemu-system-x86_64
# additional gdb commands were added, like x64-privilege-level. See gdb.py.

# to debug qemu itself:
./run.sh gdb --args /path/to/qemu-system-x86_64

# to create an archive containing the whole stack:
./build.sh
./archive_artifacts.sh stack.tar.xz
```

It's possible to automate execution of commands in the VM:

```
# Current working directory is mounted as /host in VM
# Finally, a custom command can be passed to init script using INIT env var

# To boot a VM, and call hostname:
INIT=hostname ./run.sh qemu-system-x86_64

# In case command fail, init will trigger a Kernel panic
INIT='false' ./run.sh qemu-system-x86_64
```

Finally, you can generate a [perfetto](https://perfetto.dev/) trace, based on
QEMU [uftrace plugin](https://www.qemu.org/docs/master/about/emulation.html#uftrace).
In this case, you need to use a QEMU compiled from source and master branch.

```
# generate a trace with timestamped execution
./trace.sh /path/to/built/qemu-system-x86_64
...
1760047503.162041 NOTICE:  Booting Trusted Firmware
1760047503.162544 NOTICE:  BL1: v2.13.0(debug):v2.13.0-2-gbaeb81f
1760047503.162725 NOTICE:  BL1: Built : 16:35:42, Oct  7 2025
1760047503.163462 INFO:    BL1: RAM 0xe0ee000 - 0xe0f6000
...
execution log is available in ./uftrace.data/exec.log

# generate perfetto trace (compressed json) using uftrace
from=1760047503.162041
to=1760047503.163462
./perfetto.sh $from $to ~/out.json.gz
```

---

Linux is compiled with -O2 (and relies on it), making it hard to debug.

However, you can enable debugging for specific functions by using:

```
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 27725f1ab5ab..e76fd4da8179 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -4,6 +4,8 @@

 #include <linux/compiler_types.h>

+#define DEBUGGER __attribute__((optimize("O0")))
+
 #ifndef __ASSEMBLY__

 #ifdef __KERNEL__
```

And marking functions to debug with `DEBUGGER` attribute.
